![](https://velog.velcdn.com/images/hariaus/post/cd012fe8-8a0a-4724-9c05-800f98c64b4f/image.jpg)

![](https://velog.velcdn.com/images/hariaus/post/e91c8c4d-da6d-4231-b1ee-33212b948c16/image.jpg)

## 문제 풀이 방식

처음 문제를 접했을 때는 BFS나 DFS로 접근해야 한다고 생각했으나, 이 문제는 모든 경로를 탐색할 필요가 없다.
실제로는 좌/우, 그리고 위쪽 경로만 확인하면 되므로 단순한 시뮬레이션으로 해결 가능하다.

또한 출발지를 찾기 위해 굳이 시작점부터 탐색할 필요가 없다. 도착지에서 거꾸로 올라가면 단 한 번의 탐색으로 출발지를 찾을 수 있다.

---

### 조건식

```python
 while x >= 0:
        if y - 2 >= 0 
	        if ladder[x][y - 1] == '+':
            y -= 2
        elif y + 2 < n * 2 - 1 
	        if ladder[x][y + 1] == '+':
            y += 2
        x -= 1
    print((y // 2) + 1)
```

초기에는 위와 같이 작성했는데, 이 경우 `y - 2 ≥ 0` 조건을 만족하지만 `ladder[x][y - 1] == "+"`가 아닌 상황에서는 오른쪽 검사(`y + 2 < n * 2 - 1`)로 넘어가지 않고 바로 위로 이동해 버리는 문제가 있었다.

따라서 조건을 다음과 같이 한 줄로 묶어주어야 한다.

```python
while x >= 0:
        if y - 2 >= 0 and ladder[x][y - 1] == '+':
            y -= 2
        elif y + 2 < n * 2 - 1 and ladder[x][y + 1] == '+':
            y += 2
        x -= 1
   print((y // 2) + 1)
```

---

### 전체 코드 (Python)

```python
import sys
input = sys.stdin.readline

t = int(input())

def solve(n, m, p, ladder):
    x, y = m - 1, (p - 1) * 2
    while x >= 0:
        if y - 2 >= 0 and ladder[x][y - 1] == '+':
            y -= 2
        elif y + 2 < n * 2 - 1 and ladder[x][y + 1] == '+':
            y += 2
        x -= 1
    print((y // 2) + 1)

for _ in range(t):
    n, m, d = map(int, input().split())
    ladder = [list(input().rstrip('\n')) for _ in range(m)]
    solve(n, m, d, ladder)
```

---