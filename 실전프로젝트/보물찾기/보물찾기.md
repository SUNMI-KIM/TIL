
![](https://velog.velcdn.com/images/hariaus/post/723edabc-1602-4457-9e82-c12aecfc48f7/image.png)


![](https://velog.velcdn.com/images/hariaus/post/7b600e03-39b6-41a7-bfe4-b064c0a39e29/image.png)


## 문제 풀이 방식 - BFS


처음에는 이 문제가 **BFS/DFS 유형**이라고 생각했으나, 실제로는 **단일 경로만 추적하면 되는 문제**이므로 복잡한 탐색 알고리즘이 필요하지 않다. 다만, 이동 과정을 구현할 때 **BFS의 큐 구조**를 차용하면 편리하기 때문에 BFS 형태로 풀이하였다.

---

### 1. 이동 방향 정의

이동 방향을 정하기 위해, 이동 방향 표를 파이썬의 딕셔너리를 통해 구현했다.

이동 규칙을 구현하기 위해 파이썬의 딕셔너리를 사용하였다. 

현재 방향(`d`)과 명령(`md`)에 따라 새로운 방향(`nd`)을 정할 수 있도록 구성하였다.

```python
direction_map = {
    'F': {'F': 'F', 'R': 'R', 'L': 'L', 'B': 'B'},
    'R': {'F': 'R', 'R': 'B', 'L': 'F', 'B': 'L'},
    'L': {'F': 'L', 'R': 'F', 'L': 'B', 'B': 'R'},
    'B': {'F': 'B', 'R': 'L', 'L': 'R', 'B': 'F'}
}
```

또한 실제 좌표 변화를 표현하기 위해 `dx`, `dy` 딕셔너리를 정의하였다.

```python
dx = {'F': 1, 'B' : -1, 'R' : 0, 'L' : 0}
dy = {'F': 0, 'B' : 0, 'R' : 1, 'L' : -1}
```

---

### 2. BFS 구현

문제에서 잘못된 입력이 주어지지 않으므로, 별도의 범위 검사는 필요하지 않다.

또한 BFS처럼 여러 방향을 동시에 탐색하는 것이 아니라, **입력된 한 방향만 따라 이동**하면 된다.

```python
while queue:
        x, y, d = queue.popleft()
        md, count = m[x][y][0], int(m[x][y][1])
        
        nd = direction_map[d][md]
        nx, ny = x + dx[nd] * count, y + dy[nd] * count # 여러번 한번에 이동

        visited[x][y][nd] += 1
        if visited[x][y][nd] > 1:
            return (x, y)

        queue.append((nx, ny, nd))
```

---

### 3. 방문 처리

종료 조건은 **같은 방향으로 같은 칸을 두 번 이상 이동했을 때**이다. 따라서 단순히 "방문 여부"만 체크하는 것으로는 부족하다.

이를 해결하기 위해 각 좌표마다 네 방향(`F, B, R, L`)별 방문 횟수를 저장하는 구조로 `visited` 배열을 정의하였다.

```python
visited = [[{'F': 0, 'B' : 0, 'R' : 0, 'L' : 0} for __ in range(n)] for __ in range(n)]
```

---

### 최종 코드 (Python)

```python
import sys
input = sys.stdin.readline

direction_map = {
    'F': {'F': 'F', 'R': 'R', 'L': 'L', 'B': 'B'},
    'R': {'F': 'R', 'R': 'B', 'L': 'F', 'B': 'L'},
    'L': {'F': 'L', 'R': 'F', 'L': 'B', 'B': 'R'},
    'B': {'F': 'B', 'R': 'L', 'L': 'R', 'B': 'F'}
}

dx = {'F': 1, 'B' : -1, 'R' : 0, 'L' : 0}
dy = {'F': 0, 'B' : 0, 'R' : 1, 'L' : -1}

from collections import deque

def solve(m, visited):
    queue = deque()
    queue.append((0, 0, 'B'))

    while queue:
        x, y, d = queue.popleft()
        md, count = m[x][y][0], int(m[x][y][1])
        
        nd = direction_map[d][md]
        nx, ny = x + dx[nd] * count, y + dy[nd] * count

        visited[x][y][nd] += 1
        if visited[x][y][nd] > 1:
            return (x, y)

        queue.append((nx, ny, nd))
        
            
t = int(input())
for _ in range(t):
    n = int(input())
    m = [list(map(str, input().split())) for _ in range(n)]
    visited = [[{'F': 0, 'B' : 0, 'R' : 0, 'L' : 0} for __ in range(n)] for __ in range(n)]
    x, y = solve(m, visited)
    print(x, y)

    
```