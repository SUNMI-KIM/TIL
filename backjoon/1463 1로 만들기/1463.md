
백준 1463번 문제는 정수 **X**를 1로 만드는 최소 연산 횟수를 구하는 문제이다. 주어진 연산은 다음과 같다.

- **X**가 3으로 나누어 떨어지면, 3으로 나눈다.
- **X**가 2로 나누어 떨어지면, 2로 나눈다.
- **X**에서 1을 뺀다.

예를 들어, **X**가 10일 때, 10 → 9 → 3 → 1의 과정을 거쳐 3번의 최소 연산이 발생한다. 우리는 각 단계에서 어떤 연산을 선택해야 최소 횟수를 얻을 수 있는지 판단해야 한다.

![](https://velog.velcdn.com/images/hariaus/post/7c14e495-7937-453f-96a2-911d8f0ab324/image.png)


## Dynamic Programming



DP(동적 계획법)는 하나의 큰 문제를 여러 문제로 나누고, 그 결과를 저장해 두었다가 이를 활용하여 전체 문제를 해결할 때 사용하는 방법이다. 점화식을 만들어 사용하는 알고리즘이다.


DP를 사용할 때는 점화식이나 조건문을 잘 정리한 뒤 코드로 옮기면 된다.

### DP 사용 조건

---

1. **Overlapping Subproblems ( 겹치는 부분 문제 )**

DP는 기본적으로 문제를 나누고 그 문제 결과 값을 재활용하여 전체 값을 구한다. 동일한 작은 문제들이 반복하여 나타나는 경우에 사용이 가능하다.

1. **Optimal Substructure ( 최적 부분 구조 )**

부분 문제의 최적 결과 값을 사용해 전체 문제의 최적 결과를 낼 수 있는 경우를 의미한다. 

**→ 즉, 부분 문제들의 결과가 최종 값을 계산하는 데 꼭 필요하다면 DP를 사용할 수 있다.**

## 문제 풀이 방식


이 문제는 **다이나믹 프로그래밍(DP)**을 사용해 해결할 수 있다. 상위 문제(예: 10을 1로 만드는 연산)를 하위 문제(예: 3를 1로 만드는 연산)의 해를 이용해 해결하는 방식이다.

DP 테이블 `dp[i]`는 정수 `i`를 1로 만드는 최소 연산 횟수를 의미한다.

- `dp[1]` = 0 (1은 이미 1이므로 연산 횟수 0)
- `dp[2]` = `dp[1]` + 1 = 1 (2 → 1)
- `dp[3]` = `dp[1]` + 1 = 1 (3 → 1)

**X**에 대한 최소 연산 횟수를 구하려면, 다음 세 가지 경우의 최솟값을 비교하면 된다.

- **X - 1**에서 1을 만드는 최소 연산 횟수(`dp[X-1]`)에 1을 더한 값
- **X / 2**에서 1을 만드는 최소 연산 횟수(`dp[X/2]`)에 1을 더한 값 (X가 2의 배수일 경우)
- **X / 3**에서 1을 만드는 최소 연산 횟수(`dp[X/3]`)에 1을 더한 값 (X가 3의 배수일 경우)

따라서 `dp[X]`는 `min(dp[X-1], dp[X/2], dp[X/3]) + 1`과 같이 구할 수 있다. 이 방식으로 1부터 **X**까지 순서대로 계산해 나가면 효율적으로 문제를 해결할 수 있다.

---

### 최소 연산 횟수 도출 과정 (DP)

| X | 1 뺄 때 | 2로 나눌 때 | 3으로 나눌 때 | dp[X] (최소) |
| --- | --- | --- | --- | --- |
| 1 | 시작값 → 0 | 불가능 | 불가능 | **0** |
| 2 | dp[1]+1 = 1 | dp[1]+1 = 1 | 불가능 | **1** |
| 3 | dp[2]+1 = 2 | 불가능 | dp[1]+1 = 1 | **1** |
| 4 | dp[3]+1 = 2 | dp[2]+1 = 2 | 불가능 | **2** |
| 5 | dp[4]+1 = 3 | 불가능 | 불가능 | **3** |
| 6 | dp[5]+1 = 4 | dp[3]+1 = 2 | dp[2]+1 = 2 | **2** |
| 7 | dp[6]+1 = 3 | 불가능 | 불가능 | **3** |
| 8 | dp[7]+1 = 4 | dp[4]+1 = 3 | 불가능 | **3** |
| 9 | dp[8]+1 = 4 | 불가능 | dp[3]+1 = 2 | **2** |
| 10 | dp[9]+1 = 3 | dp[5]+1 = 4 | 불가능 | **3** |

---

### 최종 코드 (Python)

```python
n = int(input())

dp = [0] * (n + 1)

for i in range(2, n + 1):
    dp[i] = dp[i - 1] + 1
    if i % 3 == 0:
        dp[i] = dp[i // 3] + 1
    if i % 2 == 0:
        dp[i] = min(dp[i], dp[i // 2] + 1)
print(dp[n])
```