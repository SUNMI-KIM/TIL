

![](https://velog.velcdn.com/images/hariaus/post/fa9be6f2-9b15-4cdf-85da-1257cb0c2893/image.png)


![](https://velog.velcdn.com/images/hariaus/post/16e1bdbe-aac7-4051-80d1-402959ec7b54/image.png)


## 문제 풀이 방식

---

백준 2840 **행운의 바퀴** 문제를 처음 보았을 때, 연결 리스트로도 구현할 수 있겠다고 생각했다. 하지만 연결 리스트는 인덱스 접근이 불가능하고 노드를 순차적으로 탐색해야 하므로, 배열 인덱스를 직접 활용하는 방법보다 비효율적이다. 따라서 배열을 사용하면서, 회전으로 인해 인덱스가 배열 범위를 넘어가더라도 안정적으로 접근할 수 있는 방법을 고민했다.

### 나머지 연산 (**Modular arithmetic**)

이를 해결하기 위해 **나머지 연산**을 적용했다. 예제 1번을 그림으로 살펴보자. 

![](https://velog.velcdn.com/images/hariaus/post/0ac318bd-a2bb-4052-ad2a-cd6656531576/image.jpeg)


첫 입력이 `1 A`일 때, 시작 인덱스는 0이다. 따라서 `start + 1`이 되어 1번 인덱스에 A가 들어간다.

![](https://velog.velcdn.com/images/hariaus/post/f9b9e086-83cf-4e61-b5d7-bcf9eb1275ac/image.png)


다음 입력이 `2 B`일 때, 시작 인덱스는 1이므로 `1 + 2 = 3`이 된다. 하지만 배열 크기가 3이라 인덱스를 벗어나므로 `(start + s) % n = 0`이 되어 0번 인덱스에 B가 들어가게 된다.

즉,

```python
start = (start + s) % n
```

공식을 이용하면 배열을 원형처럼 활용할 수 있다.

### 모순이 발생하는 경우

문제에서 “조건에 맞는 바퀴가 없다면 `!`를 출력한다”고 했다. 이 상황은 두 가지 경우로 정리할 수 있다.

1. 이미 같은 칸에 다른 글자를 쓰려고 하는 경우
2. 비어 있는 칸에 글자를 쓰려는데, 해당 글자가 이미 다른 칸에 존재하는 경우

이 경우 반복문을 즉시 종료하고 `!`를 출력한다.

```python
# 1) 해당 칸이 이미 채워져 있는데 다른 글자가 들어오려는 경우 → 모순
        if arr[start] != "?" and arr[start] != char:
            print("!")
            return

        # 2) 해당 칸은 비어 있는데, 이번에 쓰려는 글자가 이미 다른 칸에서 쓰인 경우 → 모순
        if arr[start] == "?" and char in visited:
            print("!")
            return
```

### 시계 방향 출력

처음에는 배열 인덱스를 순서대로 출력하면 시계 방향일 것이라 생각했지만, 실제로는 반시계 방향 출력이 되었다.

그 이유는 **코드에서 회전을 `start = (start + s) % n`으로 구현했기 때문**이다. 인덱스를 증가시키는 방향을 시계 방향이라고 설정했지만, 실제로 그림으로 그려보면 시계 방향 출력은 인덱스를 감소시키면서 접근해야 한다.

![](https://velog.velcdn.com/images/hariaus/post/6b7fb067-6795-478e-9fb2-c1ccfa7e295b/image.png)



```python
for i in range(0, n):
        print(arr[(start - i) % n], end = "")
    return
```

따라서 출력 구문을 다음과 같이 작성해야 올바르게 시계 방향으로 출력된다.

### 최종 코드 (Python)

```python
import sys
input = sys.stdin.readline

n, k = map(int, input().split())
visited = set()
arr = ["?"] * (n)

def solve(n, k, arr):
    start = 0
    for _ in range(k):
        s, char = map(str, input().split())
        start = (int(s) + start) % n
        
        # 1) 해당 칸이 이미 채워져 있는데 다른 글자가 들어오려는 경우 → 모순
        if arr[start] != "?" and arr[start] != char:
            print("!")
            return

        # 2) 해당 칸은 비어 있는데, 이번에 쓰려는 글자가 이미 다른 칸에서 쓰인 경우 → 모순
        if arr[start] == "?" and char in visited:
            print("!")
            return
        
        visited.add(char)
        arr[start] = char
    
    for i in range(0, n):
        print(arr[(start - i) % n], end = "")
    return

solve(n, k, arr)
```