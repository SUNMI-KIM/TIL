![](https://velog.velcdn.com/images/hariaus/post/ca4bce75-bf7a-4ce8-84e8-47e32abba4c4/image.png)

![](https://velog.velcdn.com/images/hariaus/post/3ab3c6f9-d59c-48a9-9113-bf595bbe4d48/image.png)


## 문제 해결 방식

---

처음 문제를 읽으면서 헷갈렸던 부분은 **체스판의 색칠 시작점**이 ‘맨 왼쪽 위가 검은색일 수도 있고, 흰색일 수도 있다’는 조건이었다.

직접 코드를 작성해 보니, 이 조건을 처리하기 위해 비슷한 반복문을 두 번 돌리게 되었다. 그런데 두 경우를 비교해 보니, 한 쪽의 정답이 `n`이라면 다른 쪽은 항상 `64 - n`이 되는 것을 확인할 수 있었다.

따라서 반복문은 한 번만 실행한 뒤, 두 경우 중 더 작은 값을 선택하면 된다.

또한 체스판을 8×8 배열로 직접 만드는 부분도 고민했지만, 사실은 단순히 모든 경우의 수를 확인하면 되는 문제였다. 시간 제한이 2초이므로, 최대 경우의 수는 `42 × 42 × 64 = 112,896`에 불과해 충분히 시간 안에 해결 가능하다.

```python
import sys
input = sys.stdin.readline

def check(x, y, board):
    ans = 0

    for nx in range(x, x + 8):
        for ny in range(y, y + 8):
            if (nx + ny) % 2 == 0 and board[nx][ny] != "W":
                ans += 1
            elif (nx + ny) % 2 != 0 and board[nx][ny] != "B":
                ans += 1

    return min(ans, 64 - ans)

n, m = map(int, input().split())
board = [list(str(input().strip())) for _ in range(n)]
ans = float("inf")
for x in range(n - 7):
    for y in range(m - 7):
        ans = min(check(x, y, board), ans)
print(ans)
```