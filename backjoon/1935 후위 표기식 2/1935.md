![](https://velog.velcdn.com/images/hariaus/post/c5303c9a-095b-44a8-9936-7bba7d75a2c5/image.png)


## Stack


**Stack은 후입 선출의 자료구조 (Last In First Out)이다. 데이터가 한쪽 끝에서만 삽입되고, 삭제 시 가장 위에서만 삭제된다.** 



## 후위 표기식


**연산자를 피연산자 뒤에 배치하는 수식 표기법이다.**


우리가 일상적으로 사용하는 표기법은 **중위 표기법**이다. 예를 들어, `3 * 4 + 2` 같은 식이 있다. 이 식을 후위 표기식으로 바꾸면 어떻게 될까?

후위 표기식 변환은 다음 두 가지 규칙을 따른다.

1. **피연산자(숫자)** → 결과 리스트에 바로 추가한다.
2. **연산자** → 스택에 넣되, 스택의 맨 위 연산자와 **우선순위**를 비교한다.
    - 현재 연산자의 우선순위가 더 크면 → 스택에 push
    - 현재 연산자의 우선순위가 같거나 작으면 → 스택에서 pop하여 결과에 추가 후, 현재 연산자를 push

### 중위 표기식 → 후위 표기식 변환 (`3 * 4 + 2`)

| 단계 | 토큰 | 동작/설명 | 결과 | 스택 |
| --- | --- | --- | --- | --- |
| 1 | `3` | 피연산자 → 결과에 추가 | `3` | `[]` |
| 2 | `*` | 연산자 → 스택 push | `3` | `[*]` |
| 3 | `4` | 피연산자 → 결과에 추가 | `3 4` | `[*]` |
| 4 | `+` | 스택 top `*` > `+` → pop 후 결과에 추가, `+` push | `3 4 *` | `[+]` |
| 5 | `2` | 피연산자 → 결과에 추가 | `3 4 * 2` | `[+]` |
| 6 | (끝) | 스택에 남은 연산자 pop | `3 4 * 2 +` | `[]` |

### 후위 표기식 → 중위 표기식 변환 (`3 4 * 2 +`)

후위 표기식은 이미 연산자 우선순위를 고려하여 만들어진 표현식이다. 

따라서 다시 중위 표기식으로 변환할 때는 **연산자 우선순위를 따로 신경 쓸 필요가 없고,** 스택을 활용해 역순으로 처리하면 된다.

| 단계 | 토큰 | 동작/설명 | 스택 |
| --- | --- | --- | --- |
| 1 | `3` | 피연산자 → push | `[3]` |
| 2 | `4` | 피연산자 → push | `[3, 4]` |
| 3 | `*` | 연산자 → 피연산자 2개 pop → `(3 * 4)` push | `[(3 * 4)]` |
| 4 | `2` | 피연산자 → push | `[(3 * 4), 2]` |
| 5 | `+` | 연산자 → 피연산자 2개 pop → `((3 * 4) + 2)` push | `[ ((3 * 4) + 2) ]` |
| 6 | (끝) | 스택에 남은 최종 결과 | `3 * 4 + 2` |

## 문제 풀이 방식


후위 표기식 → 중위 표기식 변환 과정과 동일하게, **스택을 이용해 연산을 수행**했다.

다만, 최종적으로는 중위 표기식을 출력하는 것이 아니라 **계산된 결과**를 출력해야 한다.

따라서 예제와 달리 스택에는 식이 아닌 **숫자 값**이 push된다.

### 최종 코드 (Python)

```python
import sys
input = sys.stdin.readline

n = int(input())
formula = input().rstrip()
dic = {}
for i in range(n):
    dic[chr(ord("A") + i)] = int(input())

def solve(formula, dic):
    stack = []
    
    for f in formula:
        if f == "*":
            stack.append(stack.pop() * stack.pop())
        elif f == "/":
            second = stack.pop()
            first = stack.pop()
            stack.append(first / second)
        elif f == "+":
            stack.append(stack.pop() + stack.pop())
        elif f == "-":
            second = stack.pop()
            first = stack.pop()
            stack.append(first - second)
        else:
            stack.append(dic[f])
    
    return stack[0]

print(f"{solve(formula, dic):.2f}")
```

`-` 와 `/` 같은 연산자는 **pop 순서**가 중요하다.

따라서 항상 `second = stack.pop()`, `first = stack.pop()` 형태로 처리해야 한다.

### eval()을 활용한 코드 (Python)

```python
import sys
input = sys.stdin.readline

n = int(input())
formula = input().rstrip()
dic = {}
for i in range(n):
    dic[chr(ord("A") + i)] = input().rstrip()

def eval_solve(formula, dic):
    stack = []
    
    for f in formula:
        if f in dic:
            stack.append(dic[f])
        else:
            second = stack.pop()
            first = stack.pop()
            stack.append(eval(f"{first}{f}{second}"))
    return stack[0]

print(f"{eval_solve(formula, dic):.2f}")
```

파이썬에는 `eval()` 함수가 있어, 문자열로 된 표현식을 바로 실행할 수 있다.

이를 이용하면 조건문으로 연산자를 나눌 필요 없이,

```python
f"{first}{f}{second}"
```

와 같은 문자열 포맷팅만으로 연산을 수행할 수 있다.