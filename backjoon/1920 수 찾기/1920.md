

![](https://velog.velcdn.com/images/hariaus/post/4e7f7104-bbd9-435f-8896-53c2dd4532cd/image.png)


## 선형 탐색 (Linear Search)


**정렬되지 않은 배열에서 차례대로 값을 확인하며 원하는 값의 인덱스를 찾는 탐색 알고리즘** 

선형 탐색은 **배열이 정렬되어 있지 않고, 배열 크기가 작을 때**(예: 10개 미만) 주로 사용된다.

### 선형 탐색 동작 과정

---

값 6을 찾는다고 가정하면, 배열의 가장 왼쪽부터 차례대로 인덱스를 증가시키며 원하는 값이 나올 때까지 탐색한다.

![](https://velog.velcdn.com/images/hariaus/post/761be52c-e6fa-4850-a261-30cdc63a8955/image.png)


## 이분 탐색 (Binary Search)



정렬된 배열에서 탐색 범위를 절반씩 줄여가며 값을 찾는 탐색 알고리즘


이분 탐색은 **배열이 반드시 정렬되어 있어야** 하며, 데이터 개수가 많을수록 효과적이다. 시간 복잡도는 `O(logN)`으로 매우 빠른 편이다.

### 이분 탐색 동작 과정

---

값 6을 찾는 경우, `start`와 `end` 인덱스의 중간값을 확인한 뒤 다음 규칙을 따른다.

1. 찾는 값이 중간값보다 크면 `start = mid + 1`로 갱신한다.
2. 찾는 값이 중간값보다 작으면 `end = mid - 1`로 갱신한다.
3. 찾는 값이 중간값과 같으면 해당 인덱스를 반환한다.

![](https://velog.velcdn.com/images/hariaus/post/bd3b6359-338d-45f2-8cee-945b9059b3f1/image.png)



### 이분탐색 코드 (Python)

---

```python
def solve(arr, num):
    start, end = 0, len(arr) - 1

    while start <= end: # start가 end보다 커지면 종료
        mid = (start + end) // 2

        if arr[mid] == num:
            return mid
        
        elif arr[mid] < num:
            start = mid + 1
        
        else:
            end = mid - 1
    
    return -1 # 값을 찾을 수 없다.
```

## 문제 풀이 과정

처음에는 선형 탐색으로 문제를 풀었지만, **최대 100,000 × 100,000 = 10^10번의 탐색**이 필요해 시간 초과가 발생했다.

이를 해결하기 위해 배열을 정렬한 뒤 **이분 탐색**을 적용했다. 또한 문제 요구사항에 맞게, 값을 찾으면 `1`, 찾을 수 없으면 `0`을 반환하도록 코드를 수정하여 통과할 수 있었다.

```python
n = int(input())
a = list(map(int, input().split()))

m = int(input())
b = list(map(int, input().split()))

a.sort()

def solve(arr, num):
    start, end = 0, len(arr) - 1

    while start <= end:
        mid = (start + end) // 2

        if arr[mid] == num:
            return 1
        
        elif arr[mid] < num:
            start = mid + 1
        
        else:
            end = mid - 1
    
    return 0

for num in b:
    print(solve(a, num))
```