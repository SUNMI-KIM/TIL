![](https://velog.velcdn.com/images/hariaus/post/b899069e-0fb3-4438-ac16-272425d2605f/image.png)


## 문제 해결 방법


이 문제의 핵심은 **투 포인터(Two Pointers) 알고리즘**을 활용하는 것이다.

1. **두 개의 인덱스(왼쪽, 오른쪽)를 사용**
    - `start`는 구간의 왼쪽 끝, `end`는 구간의 오른쪽 끝을 가리키는 인덱스이다.
    - 두 인덱스가 움직일 때마다 구간 합(`sum`)도 함께 갱신된다.
2. **포인터 이동 규칙**
    - `sum < m`일 때: 현재 구간 합이 목표값보다 작으므로, `end`를 오른쪽으로 이동시켜 구간을 확장하는 것이 바람직하다.
    - `sum > m`일 때: 구간 합이 목표값보다 크므로, `start`를 오른쪽으로 이동시켜 구간을 줄이는 것이 바람직하다.
    - `sum == m`일 때: 조건을 만족하는 경우이므로 정답(`ans`)을 1 증가시키고, 이후 `start`를 이동시켜 다음 구간을 탐색하는 것이 옳다.
3. **종료 조건**
    - `end`가 배열의 끝에 도달할 때까지 위 과정을 반복하는 것이다.

즉, 구간 합이 목표값에 비해 **작으면 확장**, **크면 축소**, **같으면 정답 증가 후 축소**라는 규칙으로 문제를 해결할 수 있는 것이다.

```python
import sys
input = sys.stdin.readline

n, m = map(int, input().split())
arr = list(map(int, input().split()))

start, end = 0, 0
sum = arr[0]
ans = 0

while end < n:
    if sum < m:
        if end == n - 1:   # 오른쪽 포인터가 끝에 도달하면 더 이동할 수 없음
            break
        end += 1
        sum += arr[end]
    
    elif sum > m:
        sum -= arr[start]
        start += 1
    
    else: # 구간 합이 m과 같으면 정답을 세고 왼쪽 포인터를 이동
        ans += 1
        sum -= arr[start]
        start += 1

print(ans)
```